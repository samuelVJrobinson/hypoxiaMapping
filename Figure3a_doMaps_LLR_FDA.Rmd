---
title: "Untitled"
author: "Yingjie"
date: "11/1/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---



# Package
```{r}
remove(list = ls())

library(tidyverse)

## DF to Raster
library(sp)
library(raster)


## Plot maps
library(tmap)
library(RColorBrewer)
library(grid) ## put plots in a panel

```


# Data

## Load data
```{r}
## load FR data
load('./data/FRmapDat.Rdata')
head(FRmapDat)
# str(FRmapDat)


## load LL data
load('./data/LLmapDat.Rdata')
head(LLmapDat)
# str(LLmapDat)


##
load('./data/FRmapDatFull.Rdata') # --> FRmapDatFull
head(FRmapDatFull)
load('./data/LLmapDatFull.Rdata') # --> LLmapDatFull
head(LLmapDatFull)
```


## Select data for plotting
```{r}

## --> 1st to choos -----------------------> 
# dat <- FRmapDat; which_dat <- 'FR'
dat <- LLmapDat; which_dat <- 'LL'


## --> 2nd to choose ---------------------->
# which_do <- 'minDO'
which_do <- 'meanDO'


## --> 3rd no need to action --------------|
slice_ls <- unique(dat$slice) %>% as.character(); slice_ls
```


## test 1
```{r eval=FALSE, include=FALSE}
slice_id <- 'June 1 - June 10'

slice_id_sep <- str_split(slice_id, " - ") %>% unlist()
date_ini     <- slice_id_sep[1] %>% as.Date(., "%b %d") %>% format(., format="%m%d"); 
date_ini     <- paste0('2014', date_ini); date_ini

df <- dat %>%
  dplyr::filter(slice == slice_id) %>%
  dplyr::select(lon, lat, which_do)

## dataframe with coordinates to raster 
coordinates(df) <- ~lon+lat 
gridded(df) <- TRUE
# class(df)
# str(df@data)

r <- raster(df) 
class(r)

## plot raster
plot(r)

## write it as a geoTIFF
fname <- paste0("./data/results/", which_dat, "map_", which_do, '_', date_ini, ".tif"); fname
# writeRaster(r, filename = fname, overwrite=TRUE)
```


## test 2

  This is the approach provided by Sam. It works but can not be read in and plot using `tmap` package.
  
```{r eval=FALSE, include=FALSE}
library(sp)
library(raster)

#Get info needed for transforming points to rasters
tempRaster <- brick("./data/2014_121.tif") #Read in first combined tif file
tempRes <- res(tempRaster); tempRes #Resolution
tempCRS <- crs(tempRaster) #CRS
tempExtent <- extent(tempRaster) #Extent

#Not sure what your workflow is, but say you only wanted a raster for the first slice:
df       <- dplyr::filter(dat, slice == slice_id) #Choose only first slice
dfCoords <- df[,c('lon','lat')]
dfData   <- df %>% dplyr::select(minDO,meanDO) #Get rid of extra info
dfsp     <- SpatialPointsDataFrame(coords = dfCoords, data = dfData, proj4string=tempCRS) #Convert to sp object

r <- raster(crs = tempCRS, vals = NA, resolution = tempRes, ext = tempExtent) %>%
  rasterize(dfsp, .)

plot(r$minDO) #Works

#Now that it's been converted, you can save it in whatever form you want using writeRaster()
## write it as a geoTIFF
fname <- paste0("./data/results/", which_dat, "map_", which_do, '_', date_ini, ".tif"); fname
# writeRaster(r, filename = fname, overwrite=TRUE)
```



## Loop DF and save as TIF
```{r}

for (slice_id in slice_ls) {
  
  ## - to get the date info
  slice_id_sep <- str_split(slice_id, " - ") %>% unlist()
  date_ini     <- slice_id_sep[1] %>% as.Date(., "%b %d") %>% format(., format="%m%d"); 
  date_ini     <- paste0('2014', date_ini); date_ini
  
  
  ## - approach 1 -------------------------------------------------- #
  ## - filter by slide and convert the df to raster
  # df       <- dplyr::filter(dat,slice == slice_id) #Choose only first slice
  # dfCoords <- df[,c('lon','lat')]
  # dfData   <- df %>% dplyr::select(meanDO) #Get rid of extra info
  # dfsp     <- SpatialPointsDataFrame(coords = dfCoords, data = dfData, proj4string=tempCRS) #Convert to sp object
  # 
  # r <- raster(crs = tempCRS, vals = NA, resolution = tempRes, ext = tempExtent) %>%
  #   rasterize(dfsp, .)
  
  
  ## - approach 2 -------------------------------------------------- #
  df <- dat %>%
  dplyr::filter(slice == slice_id) %>%
  dplyr::select(lon, lat, which_do)

  ## dataframe with coordinates to raster 
  coordinates(df) <- ~lon+lat 
  gridded(df) <- TRUE
  r <- raster(df) 
  ## --------------------------------------------------------------- #
  
  ## - write it as a geoTIFF
  fname <- paste0("./data/results/", which_dat, "map_", which_do, '_', date_ini, ".tif"); fname
  writeRaster(r, filename = fname, overwrite=TRUE)
}
```




## Map plot
```{r}

### load help data, such as the Gulf states, rivers, state boundary
load('./data/helper_data_map.RData')


### read in the DO raster
pat <- paste0(which_dat, "map_", which_do); pat
ras_ls <- list.files(path = './data/results/', pattern = pat, full.names = T); ras_ls


### test use
# ras <- ras_ls[1]; ras


### loop and plot the DO raster
for (ras in ras_ls) {
  
  ## to get a formatted name for each plot 
  date_ini <- basename(ras) %>% gsub("\\D", "", .) %>% as.Date(., "%Y%m%d"); print(date_ini)
  date_end <- (date_ini) + 9; #print(date_ini)
  # ras_nm <- paste0(date_ini, ' ~ ', date_end); print(ras_nm)
  ras_nm <- date_ini %>% gsub('-', '', .); print(ras_nm)
  map_nm <- paste0('domap_', ras_nm)
  
  dz  <- raster(ras)
  dz[dz < 0] <- 0    ## turn negative values to 0
  
  domap <-
    tm_shape(dz, bbox = bhu_bb) +
    tm_raster(style = "fixed", 
              # style = "cont",
              title = "DO (mg/l)",
              breaks = seq(0, 8, 2),
              palette = brewer.pal(9,"RdYlBu"), legend.show = F) +
    tm_shape(usa) + tm_polygons(col = "gray90",  border.col = NA, legend.show=F)+
    tm_layout(bg.color = '#4575B4', legend.height = 1,
              legend.bg.color = 'black', outer.bg.color = 'white', frame = T,
              legend.text.color = 'white', legend.title.color= 'white',
              # main.title = ras_nm, main.title.position = "left", main.title.size = 1, 
              title = ras_nm, title.position = c(0, 0.95), title.size = 0.7,
              legend.position= c("left", "bottom"))
  # domap
  
  ## to assign a name to each plot for later use
  assign(map_nm, domap)
}


## get the list of all the plots
domap_ls <- mget(ls(pattern = '^domap_2014'))


## put all plots in one panel ----------------------------------------------------------------------
library(grid)




## 1. in a 9*1 panel --------------------------

## This function aims to plot multiple maps in one column 
source('./func_domap_1col.R')
func_domap_1col(n_plots = 9, h = 3.2)


# fname <- paste0("./figures/do_maps_", which_dat, '_', which_do,  "_1col.png"); fname
# png(filename = fname, pointsize =12, width = 7/3, height = 4/3*9, units="in", res = 300)
# 
# grid.newpage()
# pushViewport(viewport(layout = grid.layout(
#   nrow = 10, ncol = 1, heights = c(0.01, rep(0.99/9, 9))
#   )))
# 
# grid.text(label = paste0(which_dat, 'R'), vp = viewport(layout.pos.row = 1))
# 
# z = 0
# for (i in 1:9) {
#   # print(i)
#   # for (j in 1:3) {
#     z = z + length(i)
#     print(z)
#     
#     if (z>9) {
#       break
#     }
#     print(domap_ls[z], vp = viewport(layout.pos.row = z+1))
#   # }
# }
# 
# dev.off()
```




```{r eval=FALSE, include=FALSE}
## 2. in a 3*3 panel --------------------------
fname <- paste0("./figures/do_maps_", which_dat, '_', which_do,  "_3col.png"); fname
png(filename = fname, pointsize =12, width = 7, height = 4, units="in", res = 300)

# by rows 
grid.newpage()
pushViewport(viewport(layout = grid.layout(
  nrow = 3,
  ncol = 3
  )))

z = 0
for (i in 1:4) {
  # print(i)
  for (j in 1:3) {
    z = z + length(i)
    print(z)
    
    if (z>9) {
      break
    }
    print(domap_ls[z], vp = viewport(layout.pos.row = i, layout.pos.col = j))
  }
}

dev.off()

```


  Put 3 map in one panel -- NOT WORKING WELL
  
```{r eval=FALSE, include=FALSE}
library(png)
library(gridExtra)

# plot1 <- readPNG('../Dead_Zone_telecoupling/figures/do_maps_1col.png')
# plot2 <- readPNG('./figures/do_maps_LL_meanDO_1col.png')
# plot3 <- readPNG('./figures/do_maps_FR_meanDO_1col.png')
# 
# grid.arrange(
#   rasterGrob(plot1), rasterGrob(plot2), rasterGrob(plot2), 
#   ncol=3)

```

