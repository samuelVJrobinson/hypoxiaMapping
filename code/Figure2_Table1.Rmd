---
title: "Figure2"
author: "Yingjie"
date: "10/7/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---


  This script aims to combine sub-plots for Figure 2. 



# Setup 
```{r}
remove(list = ls())

getwd()

library(tidyverse)
library(dplyr)

library(ggplot2)
library(ggpubr)
library(viridis)
library(tidyquant)

source('helperFunctions.R') ## mae() function
```



# Data


## Load data from 3 models. 
  
```{r - LLR and FDA data}


## 1. load llModErr and fdaErr -----------------------------------------------------------
load(file = './data/errDat.Rdata')



## --> before 2022/4/20, this data include `llModErr` and `fdaErr` seperately. Here, we need to extract these two from the 
##     updated data called `errLag`
names(errLag)
  ## "lag"      "errType"  "mean_wse" "med_oose" "max_oose" "min_oose" "modType" 
# errDat <- errLag %>%
#   dplyr::rename_with(., ~ (gsub("_oose", "", .x, fixed = TRUE))) %>%
#   dplyr::rename(withinSampErr = mean_wse) %>%
#   dplyr::select(lag, errType, med, max, min, everything())


## --> 4/25/2022: updated "errDat.Rdata" that includes all the 1000 replicates. 
##  there are several options to plot the uncertainty (shade band around the line plot) 
##  1. use the true min - max range
##  2. use the 95% quantiles range (to remove potential outliers?)
##  3. use confidence interval, IPCC AR6 defines >= 90% interval as the "very likely" range.
library(Rmisc)

# prb <- 0       # to get the actual range (min to max)
prb <- 2.5/100 # to get 95% quantiles range
# prb <- 5/100   # to get 90% quantiles range

errDat0 <- errLag %>%
  dplyr::rename(value = error) %>%
  group_by(modType, lag, errType, errType2) %>%
  dplyr::summarise(med = median(value, na.rm = T),
                   avg = mean(value, na.rm = T),
                   iqr = IQR(value, na.rm = T),
                   ## --> for the max and min, we can either use the actual max, min, or 95% quantiles range
                   # max = max(value, na.rm = T), 
                   # min = min(value, na.rm = T),
                   min = quantile(value, prb),
                   max = quantile(value, probs = 1-prb),
                   ### --> or use confidence interval ---
                   # lci = CI(value, ci = 0.9)['lower'],
                   # uci = CI(value, ci = 0.9)['upper']
                   # avg1 = CI(value)['mean']
                   ) %>%
  dplyr::select(modType, lag, errType, med, max, min, everything())

### error data for training set
errDat1 <- errDat0 %>%
  dplyr::filter(errType2 == "Out of Sample") %>%
  dplyr::select(-errType2)

### error data for testing set, and only take the median for use
errDat2 <- errDat0 %>%
  dplyr::filter(errType2 == "Within Sample") %>%
  dplyr::select(modType, lag, errType, med) %>%
  dplyr::rename(withinSampErr = med)

### put both in one file
errDat <- merge(errDat1, errDat2, by = c("modType", "lag", "errType"))



## filter out data for each model --------------------------------------------------------
llModErr <- errDat %>%
  dplyr::filter(modType == 'Lagged Linear') %>%
  dplyr::select(-modType)


fdaErr  <- errDat %>%
  dplyr::filter(modType == 'Functional Data Analysis')%>%
  dplyr::select(-modType)
```


```{r - RF data}
## 2. load RF model error data --------------------------------------------------------------------
fname <- paste0('./data/results_RF/err_rf_Day_DObottom_2014_2014.Rdata'); fname
load(fname)

acc_set <- 'testing'

### input data for plotting 
acc0 <- err_rf %>%
  gather(key = 'errType', value = 'value', RMSE:R2) %>%
  dplyr::mutate(errType = factor(errType, levels = c('R2', 'RMSE', 'MAE')))

### option 1. use mean, se OR sd,for plotting ----
###   `summarySE` provides the standard deviation, standard error of the mean, and a (default 95%) confidence interval
library(Rmisc)
# rfErr <- summarySE(data = acc0, measurevar="value", groupvars=c("year", "nw", "errType")) %>%
#   dplyr::select(-year, -N) %>%
#   dplyr::rename(lag = nw)



### option 2. use median, max, min for plotting -----
rfErr <- acc0 %>%
  dplyr::select(-year) %>%
  dplyr::rename(lag = nw) %>%
  group_by(lag, errType) %>%
  dplyr::summarise(med = median(value, na.rm = T),
                   # max = max(value, na.rm = T), 
                   # min = min(value, na.rm = T), 
                   min = quantile(value, prb),
                   max = quantile(value, probs = 1-prb),
                   avg = mean(value, na.rm = T),
                   iqr = IQR(value, na.rm = T)       ## IQR = Q3-Q1 ('Interquartile Range' = 'third quartile' - 'first quartile')
                   # lci = CI(value, ci = 0.9)['lower'],
                   # uci = CI(value, ci = 0.9)['upper']
                   ) %>% 
  # dplyr::select(-avg, -iqr) %>% ## updated on 4/21/2022 using new data
  dplyr::mutate(withinSampErr = NA) %>%
  dplyr::filter(lag <= 80) %>%
  as.data.frame()
  

## --> add within-sample-error (i.e., training accuracy) of RF model
rfErr_training <- err_rf_train %>%
  gather(key = 'errType', value = 'value', RMSE:R2) %>%
  dplyr::mutate(errType = factor(errType, levels = c('R2', 'RMSE', 'MAE'))) %>%
  dplyr::select(-year) %>%
  dplyr::rename(lag = nw) %>%
  group_by(lag, errType) %>%
  dplyr::summarise(med = median(value, na.rm = T), ## median
                   # max = max(value, na.rm = T), 
                   # min = min(value, na.rm = T), 
                   min = quantile(value, prb),
                   max = quantile(value, probs = 1-prb),
                   avg = mean(value, na.rm = T),
                   iqr = IQR(value, na.rm = T)) %>%
  dplyr::select(-avg, -iqr) %>%
  dplyr::filter(lag <=80) %>%
  as.data.frame()

## --> final RF 
rfErr$withinSampErr <- rfErr_training$med




## 3. fix and unify the data frame format ----------------------------------------------------------

names(fdaErr)
names(llModErr)
names(rfErr)

## make sure `fdaErr` is the same format as `llModErr`
# fdaErr <- fdaErr %>% 
#   dplyr::rename(errType=name, 
#                 max = upr, 
#                 min = lwr) %>%
#   dplyr::mutate(iqr = NA) %>%
#   dplyr::select(names(llModErr))



# names(fdaErr)
# fdaErr_na10 <- fdaErr %>%
#   dplyr::filter(lag < 20) %>%
#   dplyr::mutate(lag = lag - 10) %>%
#   dplyr::mutate_at(vars(med:withinSampErr), ~replace(., is.numeric(.), NA))
#   # dplyr::mutate_at(c("med","max","min","iqr","withinSampErr"), as.na(), na.rm = TRUE)
# 
# fdaErr <- rbind(fdaErr, fdaErr_na10)
```


## Table 1 - result summary
```{r}
names(rfErr)


### for training data set
rfErr_training %>% 
  ungroup() %>%
  dplyr::filter(lag < 5) %>%
  group_by(errType) %>%
  # dplyr::summarise() %>%
  arrange(errType, med) %>%
  as.data.frame()

### for testing data set
rfErr %>% 
  ungroup() %>%
  dplyr::filter(lag < 5) %>%
  group_by(errType) %>%
  # dplyr::summarise() %>%
  arrange(errType, med) %>%
  as.data.frame()
```



## Plot 3 models 

```{r}
model_fullname <- c('Lagged Linear Regression', 'Random Forest Regression', 'Functional Data Analysis')

## 1. the input data for plot
err_3models <- rbind(llModErr %>% dplyr::mutate(mod = 'LLR'),
                     fdaErr   %>% dplyr::mutate(mod = 'FDA'),
                     rfErr    %>% dplyr::mutate(mod = 'RFR')) %>%
  dplyr::mutate(lag = -lag) %>%
  group_by(mod, errType) %>%
  dplyr::mutate(med_avg = mean(med, rm.na = T)) %>% ## to get the mean of median value
  ungroup() %>%
  arrange(mod, errType) %>%
  dplyr::mutate(mod = factor(mod, levels = c('LLR', 'RFR', 'FDA'), labels = model_fullname),
                errType = factor(errType, levels = c('MAE', 'RMSE', 'R2'))) %>%
  as.data.frame()


str(err_3models)

## 2. identify the best day by looking for the date with the highest model accuracy 
# err_3models_bestday <- err_3models %>% 
#   dplyr::mutate(mod = as.factor(mod), errType = as.factor(errType)) %>%
#   group_by(mod, errType) %>%
#   dplyr::mutate(best    = ifelse(errType != 'R2', min(med), max(med, na.rm = T)),
#                 bestday = ifelse(med == best, lag, NA)) %>%
#   arrange(mod, errType, med) %>%
#   # dplyr::filter(!is.na(bestday)) %>%
#   as.data.frame()



### 3. plot
(p <- ggplot(data = err_3models, aes(x=lag, y=med))+
# (p <- ggplot(data = err_3models, aes(x=lag, y=avg))+
    geom_line()+
    geom_line(aes(y=withinSampErr), col='red', alpha = 0.8, linetype = 'dashed')+
    geom_ribbon(aes(ymax = max, ymin = min), alpha = 0.3)+
    # geom_ribbon(aes(ymax = uci, ymin = lci), alpha = 0.3)+
    scale_color_viridis() +
    
    ## --> To highlight the best data range for prediction  
    # geom_vline(data = err_3models_bestday,  aes(xintercept = bestday), linetype = "dashed", color="blue") + 
    geom_rect(
      data = data.frame(mod = factor(model_fullname[1:2])), ## not to add 'rect' for FDA
      aes(x = NULL, y = NULL, xmin=-4,xmax=0, ymin=-Inf, ymax=Inf), 
      fill = 'blue', alpha=0.1) + 
    facet_grid(errType~mod, scales = 'free_y')+
    labs(x='Time lag', y='Model Accuracy') +
    theme_bw() +
    theme(legend.position = c(0.06, 0.75))
)
# library(lemon)
# reposition_legend(p, 'left')
# ggsave('./figures/accuracy_comparison_3models80d.png', p, width=7, height=5)
```



```{r - plot with legend}
## 1. the input data for plot
err_3models_long <- err_3models %>%
  gather(key = set, value = value, c(med, withinSampErr)) %>%
  as.data.frame() %>%
  dplyr::mutate(set = as.factor(set))

err_3models_long$set = factor(x = err_3models_long$set, levels = c('med', 'withinSampErr'), labels = c('Testing', 'Training'))

levels(err_3models_long$mod)

### 3. plot
(p <- ggplot(data = err_3models_long, aes(x=lag, y=value))+
    
    geom_line(aes(color = set, linetype = set), size = 0.3)+
    scale_colour_manual(values = c('black', 'red')) +
    scale_linetype_manual(values = c('solid', 'dashed')) +
    # scale_
    geom_ribbon(aes(ymax = max,ymin = min), alpha = 0.3, show.legend = F)+
    # geom_ribbon(aes(ymax = uci, ymin = lci), alpha = 0.3, show.legend = F)+
    ## --> To highlight the best data range for prediction  
    geom_rect(
      data = data.frame(mod = factor(c('Lagged Linear Regression', 'Random Forest Regression'))), ## not to add 'rect' for FDA
      aes(x = NULL, y = NULL, xmin=-4,xmax=0, ymin=-Inf, ymax=Inf), 
      fill = 'blue', alpha=0.1, show.legend = F) + 
    facet_grid(errType~mod, scales = 'free_y')+
    labs(x='Time lag', y='Model Accuracy') +
    theme_bw() +
    theme(legend.position = c(0.92, 0.74),
          legend.key=element_blank(),  ## remove the key background
          legend.key.height = unit(0.01, 'npc'),
          legend.title = element_blank(),
          legend.background = element_rect(fill='transparent'),
          legend.box.background = element_rect(fill='transparent', color = 'transparent'))
)

fname <- paste0('./figures/accuracy_comparison_3models80d_legend', (1-prb*2)*100, '.png'); fname
ggsave(filename = fname, p, width=7, height=5)
```












***************************** THE END ***************************** 

**The following code was used for FDA results without testing accuracy when feeding in different time ranges data**

  Tried `mean` value too, and it looks `mean` value is easier to identify the *best day*. 
  
  --> also thinking about to highlight days with higher accuracy then the average of (medians)
  
  --> but still, no clear pattern found. So, just present the trends of `median`...
  
```{r eval=FALSE, include=FALSE}

## 1. the input data for plot
err_2models <- rbind(llModErr %>% dplyr::mutate(mod = 'LLR'),
                     rfErr    %>% dplyr::mutate(mod = 'RFR')) %>%
  dplyr::mutate(lag = -lag) %>%
  group_by(mod, errType) %>%
  dplyr::mutate(med_avg = mean(med, rm.na = T)) %>% ## to get the mean of median value
  ungroup() %>%
  arrange(mod, errType) %>%
  as.data.frame()



## 2. identify the best day by looking for the date with the highest model accuracy 
err_2models_bestday <- err_2models %>% 
  dplyr::mutate(mod = as.factor(mod), errType = as.factor(errType)) %>%
  group_by(mod, errType) %>%
  dplyr::mutate(best    = ifelse(errType != 'R2', min(med), max(med, na.rm = T)),
                bestday = ifelse(med == best, lag, NA)) %>%
  arrange(mod, errType, med) %>%
  # dplyr::filter(!is.na(bestday)) %>%
  as.data.frame()

### - to add the 2nd best day as well?
err_2models_bestday21 <- err_2models %>% 
  ungroup() %>%
  dplyr::filter(errType != 'R2') %>%
  dplyr::group_by(mod, errType) %>%
  arrange(mod, errType, med) %>%
  dplyr::slice(2) %>%
  dplyr::mutate(bestday = lag) %>%
  as.data.frame()

err_2models_bestday22 <- err_2models %>% 
  ungroup() %>%
  dplyr::filter(errType == 'R2') %>%
  dplyr::group_by(mod, errType) %>%
  arrange(mod, errType, desc(med)) %>%
  dplyr::slice(2) %>%
  dplyr::mutate(bestday = lag) %>%
  as.data.frame()

err_2models_bestday2 <- rbind(err_2models_bestday21, err_2models_bestday22)




### 3. plot
(p1 <- ggplot(err_2models, aes(x=lag, y=med))+
    geom_ribbon(aes(ymax=max,ymin=min),alpha=0.3)+
    # geom_line(aes(color = ifelse(med>med_avg, 1, 2)))+                  # size = ifelse(med>med_avg, 1, 0.5)
    geom_line()+
    scale_color_viridis() +
    geom_line(aes(y=withinSampErr),col='red')+
    geom_vline(data = err_2models_bestday,  aes(xintercept = bestday), linetype = "dashed", color="blue") + 
    # geom_vline(data = err_2models_bestday2, aes(xintercept = bestday), linetype = "dashed", color="green") +  ## --> not good
    facet_grid(errType~mod, scales = 'free_y')+
    labs(x='Time lag',y='Model Accuracy') +
    theme_bw()
)
```






